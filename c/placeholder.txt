import numpy as np
import cv2
from sklearn.metrics import jaccard_score
import os
from matplotlib import pyplot as plt

# Path to the dataset and segmentation results
path_to_data = '../../proj_try/dataset2/1/face_crop/'
path_to_segmented_op = '../../proj_try/dataset2/1/face_crop_segmentation/'
image_names = os.listdir(path_to_data)
image_names = sorted(image_names)
ans_names = os.listdir(path_to_segmented_op)
ans_names = sorted(ans_names)

def segment_image_using_canny(img_name, ans_name, show=False, save=True, low_threshold=100, high_threshold=200):
    # Takes in one image and returns the segmented output i.e. seg and also returns the Jaccard score
    img = cv2.imread(path_to_data + img_name)
    seg = cv2.imread(path_to_segmented_op + ans_name)
    
    # Convert the image to grayscale
    gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    
    # Apply Canny edge detection
    canny_edges = cv2.Canny(gray_img, low_threshold, high_threshold)
    
    # Find contours in the Canny edge-detected image
    contours, _ = cv2.findContours(canny_edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    # Create a black image of the same size as the original image
    filled_image = np.zeros_like(gray_img, dtype=np.uint8)
    
    # Fill the contours with white (255)
    cv2.drawContours(filled_image, contours, -1, (255), thickness=cv2.FILLED)
    
    # Process the segmentation mask (converting to binary)
    seg = seg.reshape(-1, 3)
    seg2 = np.zeros((seg.shape[0]))
    
    # Convert the segmented mask to binary (1 for mask, 0 for non-mask)
    for i in range(seg.shape[0]):
        val = seg[i][0]
        if abs(255 - val) < abs(val - 0):
            val = 1  # Mask area
        else:
            val = 0  # Non-mask area
        seg2[i] = val

    seg = seg2
    filled_image2 = np.zeros_like(filled_image)
    filled_image2[filled_image==255] = 1
    filled_image = filled_image2
    # Calculate Jaccard score (intersection over union) for both possible labelings
    s1 = jaccard_score(y_true=seg.flatten(), y_pred=filled_image.flatten())
    s2 = jaccard_score(y_true=seg.flatten(), y_pred=1 - filled_image.flatten())
    
    # Choose the best Jaccard score
    score = max(s1, s2)
    print('score is ', score)
    
    # If necessary, flip the labels to match the mask region
    if s1 < s2:
        filled_image = 1 - filled_image
    
    # Show the results if required
    if show:
        plt.title('Canny Edge Detected and Filled Contours for ' + img_name)
        plt.axis('off')
        plt.imshow(filled_image, cmap='gray')
        plt.show()
        plt.close()

        plt.title('Ground Truth result for ' + ans_name)
        plt.axis('off')
        plt.imshow(seg.reshape(img.shape[:2]), cmap='gray')
        plt.show()
        plt.close()

    # Save the results to a file if required
    if save:
        plt.title('Canny Edge Detected and Filled Contours for ' + img_name)
        plt.axis('off')
        plt.imshow(filled_image, cmap='gray')
        plt.savefig(f'./output/canny_filled/{img_name}')
        plt.close()

    return (seg.reshape(img.shape[:2]), score)

# Calculate average Jaccard score over a set of images
tot = 0
count = 5  # You can adjust the number of images to process
for i in range(0, count):
    seg_pred, score = segment_image_using_canny(image_names[i], ans_names[i], show=True, save=False)
    print(f"Jaccard Score for {image_names[i]}: {score}")
    tot += score

print('Average Jaccard score:', tot / count)
